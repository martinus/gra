#!/usr/bin/env python3

"""
gra - Git Repo Admin

The repository administrator helps organize and manage git repositories. It structures
repositories under gra's root location (default: ~/git) like this:

~/git
├── github.com
│   ├── martinus
│   │   ├── gra
│   │   └── unordered_dense
└── sourceware.org
    └── git
        └── glibc

CONFIGURATION

gra is configured in your ~/.gitconfig. Most importantly, set your gra.root:

    git config --global gra.root ~/develop

It provides pre and post commands that can be automatically executed. Here is
a sample configuration:

[gra]
    root = ~/develop
    post-clone = "git maintenance register"
    pre-rm = "git maintenance unregister"
"""

__version__ = "0.4.0"

import argparse
import os
import pathlib
import re
import shutil
import subprocess
import json
from typing import Callable

# ANSI color codes
BLUE, CYAN, GREEN, YELLOW, RED = (
    "\x1b[38;5;4m",
    "\x1b[38;5;38m",
    "\x1b[38;5;2m",
    "\x1b[38;5;3m",
    "\x1b[38;5;1m",
)
BOLD, ENDC = "\033[1m", "\033[0m"

_quiet = False


def log(msg: str, color: str = BLUE) -> None:
    if not _quiet:
        print(f"{color}{msg}{ENDC}")


def log_header(msg: str) -> None:
    if not _quiet:
        print(f"{BOLD}{CYAN}── {msg} {'─' * (95 - len(msg))}{ENDC}")


def git_config(name: str) -> str | None:
    try:
        return subprocess.check_output(
            ["git", "config", "--get", name], encoding="utf-8"
        ).strip()
    except subprocess.CalledProcessError:
        return None


class GitRepoAdmin:
    def __init__(self, args: argparse.Namespace, db_file: str, root: str):
        self._args = args
        self._db_file = os.path.expandvars(os.path.expanduser(db_file))
        self._root = os.path.expandvars(os.path.expanduser(root))

    def _load_db(self) -> list[str]:
        """Load repositories from database, creating empty db if needed."""
        if not os.path.isfile(self._db_file):
            os.makedirs(os.path.dirname(self._db_file), exist_ok=True)
            pathlib.Path(self._db_file).write_text(
                json.dumps({"repositories": []}, indent="\t")
            )
        return json.loads(pathlib.Path(self._db_file).read_text())["repositories"]

    def _save_db(self, repos: list[str]) -> None:
        """Save repositories to database, sorted and unique."""
        repos = sorted(set(repos), key=str.lower)
        pathlib.Path(self._db_file).write_text(
            json.dumps({"repositories": repos}, indent="\t")
        )

    def _existing_repos(self) -> list[str]:
        """Return repositories that actually exist on disk."""
        return [r for r in self._load_db() if os.path.exists(r)]

    def _modify_db(self, fn: Callable[[list[str]], None]) -> None:
        """Load db, apply modification function, save."""
        repos = self._load_db()
        fn(repos)
        self._save_db(repos)

    def _url_to_path(self, url: str) -> str:
        """Convert a git URL to a local path under the root directory."""
        for pattern in [r"https\://(.*)", r"(?:ssh\://)?git\@(.*)", r"git://(.*)"]:
            if m := re.match(pattern, url):
                parsed = m.group(1).removesuffix(".git").replace(":", "/")
                return os.path.join(self._root, parsed)
        raise SyntaxError(f"cannot parse URL '{url}'")

    def _run_hook(self, name: str, path: str) -> None:
        if cmd := git_config(name):
            log(f"Running '{name}' command '{cmd}'")
            subprocess.run(cmd, shell=True, cwd=path)

    def _clone(self) -> None:
        for idx, url in enumerate(self._args.url):
            path = self._url_to_path(url)
            os.makedirs(path, exist_ok=True)
            self._run_hook("gra.pre-clone", path)

            cmd = ["git", "clone"]
            if not self._args.no_submodules:
                cmd += ["--recurse-submodules", "--remote-submodules"]
            cmd += [url, path]

            log(f"{idx + 1}/{len(self._args.url)} Cloning '{url}")
            subprocess.run(cmd)
            self._modify_db(lambda repos: repos.append(path))
            self._run_hook("gra.post-clone", path)

    def _each(self) -> None:
        repos = self._existing_repos()
        log(f"running '{' '.join(self._args.exec)}' in each repository")
        for idx, repo in enumerate(repos):
            log_header(f"{idx + 1}/{len(repos)} {repo}")
            cmd = [
                s.replace("{{GRA_ROOT}}", self._root).replace("{{GRA_REPO}}", repo)
                for s in self._args.exec
            ]
            subprocess.run(cmd, cwd=repo)

    def _ls(self) -> None:
        for repo in self._existing_repos():
            print(repo)

    def _updatedb(self) -> None:
        repos = []
        for root, dirs, _ in os.walk(self._root):
            if ".git" in dirs:
                log(f"found '{root}'")
                repos.append(root)
                dirs.clear()
        self._save_db(repos)
        log(
            f"found {len(repos)} repositories in '{self._root}', updated '{self._db_file}'",
            GREEN,
        )

    def _rm(self) -> None:
        p = os.path.abspath(os.path.expandvars(os.path.expanduser(self._args.path)))

        if not os.path.exists(p):
            log(f"ERROR: directory '{p}' does not exist!", RED)
            exit(1)
        if not os.path.exists(os.path.join(p, ".git")):
            log(f"ERROR: directory '{p}' is not a git repository!", RED)
            exit(1)
        if not p.startswith(self._root):
            log(f"ERROR: directory '{p}' is not inside the root '{self._root}'!", RED)
            exit(1)

        origin_url = subprocess.check_output(
            ["git", "config", "--get", "remote.origin.url"], encoding="utf-8", cwd=p
        ).strip()

        git_status = subprocess.check_output(
            ["git", "status", "--porcelain"], encoding="utf-8", cwd=p
        ).strip()
        if git_status:
            log(f"WARNING: repository has modifications:\n{git_status}", YELLOW)

        yes_no = input(
            f"{BLUE}remove directory '{p}', origin '{origin_url}'{ENDC} [y/n]? "
        )
        if yes_no == "n":
            return
        if yes_no != "y":
            log(f"ERROR: not removing, got '{yes_no}' instead of [y/n]", RED)
            exit(1)

        self._run_hook("gra.pre-rm", p)
        shutil.rmtree(p)

        # Remove empty parent directories up to root
        path = pathlib.Path(p).parent
        root = pathlib.Path(self._root)
        try:
            while root in path.parents:
                path.rmdir()
                path = path.parent
        except OSError:
            pass

        self._modify_db(lambda repos: repos.remove(p))
        log(f"removed '{p}'", GREEN)

    def run(self) -> None:
        commands = {
            "clone": self._clone,
            "each": self._each,
            "ls": self._ls,
            "root": lambda: print(self._root),
            "rm": self._rm,
            "updatedb": self._updatedb,
        }
        commands[self._args.cmd]()


if __name__ == "__main__":
    DB_FILE = "~/.local/share/gra/db.json"
    FALLBACK_ROOT = "~/git"

    os.environ["GIT_ASK_YESNO"] = "1"

    root = os.path.expandvars(
        os.path.expanduser(git_config("gra.root") or FALLBACK_ROOT)
    )

    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "-q", "--quiet", action="store_true", help="do not print any status information"
    )
    parser.add_argument(
        "-v", "--version", action="version", version="%(prog)s " + __version__
    )

    subparsers = parser.add_subparsers(required=True, dest="cmd", title="commands")

    p = subparsers.add_parser(
        "clone",
        formatter_class=argparse.RawTextHelpFormatter,
        help="clone one or more remote repository",
        description=f"""Clones one or more repository into the gra root directory '{root}'. The
repository directory is created based on the URL and it is registered into
gra's database.""",
    )
    p.add_argument(
        "--no-submodules", action="store_true", help="Skip fetching of submodules"
    )
    p.add_argument("url", nargs="+", help="one or more git repository URLs to clone")

    p = subparsers.add_parser(
        "each",
        formatter_class=argparse.RawTextHelpFormatter,
        help="run a command in the working directory of each repository",
        description=f"""Runs the given command with all arguments for each repository. The working directory of each command
is its repository, and the commands can use these strings which are automatically replaced:

{{{{GRA_ROOT}}}}: Replaced by gra root directory '{root}'.
{{{{GRA_REPO}}}}: Replaced by the full path of each repository.

Here are examples that you can try. Show short git status of each repository:

    gra each git status -sb

Show disk usage of each repository. I use {{{{GRA_REPO}}}} so `du` shows the path, and the argument -q
to hide gra's status output:

    gra -q each du -h -d0 {{{{GRA_REPO}}}}""",
    )
    p.add_argument("exec", nargs=argparse.REMAINDER, help="the command")

    subparsers.add_parser(
        "ls",
        formatter_class=argparse.RawTextHelpFormatter,
        help="list all repositories",
        description="""Simply list all repositories. The list is updated automatically on each clone,
but if you add/remove repositories without the script, run `updatedb` to
update the index.""",
    )

    subparsers.add_parser(
        "root",
        formatter_class=argparse.RawTextHelpFormatter,
        help=f"shows repository root, currently '{root}'",
        description=f"""Prints the root path used by gra. The path is configured in the global
~/.gitconfig. If not configured, the default is '{FALLBACK_ROOT}'. Set the
configuration with e.g.

    git config --global gra.root ~/git

This root folder is used as the base for all commands.""",
    )

    p = subparsers.add_parser(
        "rm",
        formatter_class=argparse.RawTextHelpFormatter,
        help="removes a local repository",
        description="""Removes a local git repository. This removes all empty parent directores (not including
the root) as well.

You have to confirm with 'y' before actual removal takes place.""",
    )
    p.add_argument("path", help="repository to remove")

    subparsers.add_parser(
        "updatedb",
        formatter_class=argparse.RawTextHelpFormatter,
        help="crawls the gra root to update the list of repositories",
        description=f"""Walks through the whole directory tree in the root path '{root}' to find all
directories that contain a '.git' folder. These are then set as the repositories
in the database.

Usually there is no need to call that command, unless you add repositories without the
'clone' command. The repositories are then sorted and stored into '{DB_FILE}'.""",
    )

    args = parser.parse_args()
    _quiet = args.quiet

    GitRepoAdmin(args, DB_FILE, root).run()
